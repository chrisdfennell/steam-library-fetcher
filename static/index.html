<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Steam Library Fetcher</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f9; }
        h1, h2, h3 { color: #333; }
        .container { max-width: 1200px; margin: 0 auto; }
        .section { margin-bottom: 40px; }
        .section ul { list-style-type: none; padding: 0; }
        .section li { background-color: #fff; padding: 10px; margin-bottom: 5px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .game-name { font-weight: bold; }
        .game-playtime { color: #555; }
        .game-details { display: none; padding: 5px; background: #f9f9f9; }
        .playtime-bar { background: #ddd; height: 10px; margin-right: 10px; }
        .playtime-bar-fill { background: #4caf50; height: 100%; }
        .error { color: red; }
        .info { color: blue; }
        #copyButton { margin-left: 10px; cursor: pointer; }
        .filter { margin: 10px 0; display: flex; flex-wrap: wrap; align-items: center; gap: 10px; background: #fff; padding: 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        #searchInput { padding: 5px; width: 300px; border: 1px solid #ccc; border-radius: 5px; }
        .pagination { margin-top: 10px; display: flex; gap: 10px; justify-content: center; }
        .pagination button { padding: 5px 10px; cursor: pointer; }
        .pagination button:disabled { cursor: not-allowed; opacity: 0.5; }
        .toggle-section { font-size: 0.8em; margin-left: 10px; cursor: pointer; }
        .favorite-btn { margin-right: 10px; cursor: pointer; background: none; border: none; }
        .dark-mode { background-color: #222; color: #fff; }
        .dark-mode .section li { background-color: #333; color: #fff; }
        .dark-mode .filter, .dark-mode .pagination { background-color: #444; }
        .dark-mode .game-details { background: #555; }
        .dark-mode .playtime-bar { background: #666; }
        .dark-mode .playtime-bar-fill { background: #66bb6a; }
        #darkModeToggle { 
            position: fixed; 
            bottom: 20px; 
            right: 20px; 
            font-size: 24px; 
            cursor: pointer; 
            background: none; 
            border: none; 
            padding: 10px; 
            border-radius: 50%; 
            background-color: #fff; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
        }
        .dark-mode #darkModeToggle { background-color: #444; }
        .game-item { display: flex; align-items: center; cursor: pointer; }
        .game-item img { width: 32px; height: 32px; margin-right: 10px; }
        .favorite { color: gold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Steam Library Fetcher</h1>
        <p class="info">Don’t know your Steam username? <a href="https://steamcommunity.com/my/profile" target="_blank">Click here to visit your Steam profile</a>. Look for a URL like <code>steamcommunity.com/id/yourusername</code>. If you don’t have a custom URL, copy the 17-digit SteamID64 from a URL like <code>steamcommunity.com/profiles/7656119...</code>.</p>

        <form id="steamForm">
            <label for="userInput">Your Steam Username or SteamID64:</label><br>
            <input type="text" id="userInput" name="userInput" placeholder="e.g., gabelogannewell or 76561197960434622"><br>
            <label for="friendInput">Friend's Steam Username or SteamID64:</label><br>
            <input type="text" id="friendInput" name="friendInput" placeholder="e.g., friendusername or 7656119..."><br><br>
            <button type="submit">Get Libraries</button>
        </form>

        <h2>Your Steam ID: <span id="steamId"></span> <button id="copyButton" style="display:none;">Copy SteamID</button></h2>

        <div class="section" id="statsSection">
            <h3>Library Statistics <button class="toggle-section">Toggle</button></h3>
            <ul id="statsList"></ul>
        </div>

        <div class="section" id="trendsSection">
            <h3>Playtime Trends <button class="toggle-section">Toggle</button></h3>
            <canvas id="playtimeChart" width="400" height="200"></canvas>
        </div>

        <div class="section" id="topGamesSection">
            <h3>Top 20 Games by Playtime <button class="toggle-section">Toggle</button></h3>
            <ul id="topGamesList"></ul>
        </div>

        <div class="section" id="recentGamesSection">
            <h3>Recently Played Games <button class="toggle-section">Toggle</button></h3>
            <ul id="recentGamesList"></ul>
        </div>

        <div class="section" id="compareSection">
            <h3>Library Comparison <button class="toggle-section">Toggle</button></h3>
            <ul id="compareList"></ul>
        </div>

        <div class="section" id="fullListSection">
            <h3>Full List</h3>
            <div class="filter">
                <label><input type="checkbox" id="showPlayedOnly"> Show only games with playtime > 0</label>
                <label><input type="checkbox" id="filterWindows"> Windows</label>
                <label><input type="checkbox" id="filterMac"> Mac</label>
                <label><input type="checkbox" id="filterLinux"> Linux</label>
                <label><input type="checkbox" id="filterDeck"> Steam Deck</label>
                <input type="text" id="searchInput" placeholder="Search games by name...">
                <label>Sort by:
                    <select id="sortBy">
                        <option value="name">Name (A-Z)</option>
                        <option value="playtime">Total Playtime (High to Low)</option>
                        <option value="lastPlayed">Last Played (Recent to Oldest)</option>
                        <option value="playtime2Weeks">Playtime in Last 2 Weeks (High to Low)</option>
                    </select>
                </label>
                <label>Played in:
                    <select id="dateRange">
                        <option value="all">All Time</option>
                        <option value="last30Days">Last 30 Days</option>
                        <option value="lastYear">Last Year</option>
                    </select>
                </label>
                <button id="exportCsv">Export to CSV</button>
                <button id="shareLink">Copy Shareable Link</button>
            </div>
            <ul id="gameList"></ul>
            <div class="pagination">
                <button id="prevPage" disabled>Previous</button>
                <span id="pageInfo"></span>
                <button id="nextPage">Next</button>
            </div>
        </div>

        <p id="errorMessage" class="error"></p>
    </div>

    <button id="darkModeToggle" title="Toggle Dark/Light Mode">🌙</button>

    <script>
        let allGames = []; // For Top 20 and Recently Played
        let currentPageGames = []; // For Full List (paginated)
        let friendGames = [];
        let currentPage = 1;
        let totalPages = 1;
        let totalGames = 0;
        const gamesPerPage = 50;
        const twoWeeksInSeconds = 14 * 24 * 60 * 60;
        const currentTimestamp = Math.floor(Date.now() / 1000);
        let favorites = JSON.parse(localStorage.getItem('favorites')) || [];
        let userUrl = '';
        let steamId = '';

        document.getElementById('steamForm').addEventListener('submit', function(event) {
            event.preventDefault();
            fetchAndRender();
        });

        function fetchAndRender() {
            const userInput = document.getElementById('userInput').value.trim();
            const friendInput = document.getElementById('friendInput').value.trim();
            const gameList = document.getElementById('gameList');
            const topGamesList = document.getElementById('topGamesList');
            const recentGamesList = document.getElementById('recentGamesList');
            const compareList = document.getElementById('compareList');
            const steamIdDisplay = document.getElementById('steamId');
            const copyButton = document.getElementById('copyButton');
            const errorMessage = document.getElementById('errorMessage');

            // Clear previous results
            gameList.innerHTML = '';
            topGamesList.innerHTML = '';
            recentGamesList.innerHTML = '';
            compareList.innerHTML = '';
            steamIdDisplay.textContent = '';
            copyButton.style.display = 'none';
            errorMessage.textContent = '';
            currentPage = 1;
            allGames = [];
            friendGames = [];

            if (!userInput) {
                errorMessage.textContent = 'Please enter your username or SteamID64.';
                return;
            }

            userUrl = /^\d{17}$/.test(userInput) ?
                `/get_library_by_id?steamid=${encodeURIComponent(userInput)}` :
                `/get_library?username=${encodeURIComponent(userInput)}`;

            // Fetch the full list for Top 20 and Recently Played (use a reasonable per_page)
            fetch(`${userUrl}&page=1&per_page=2000`, { mode: 'cors' })
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    return response.json();
                })
                .then(userData => {
                    console.log('Fetched full data:', userData);
                    if (userData.error) {
                        errorMessage.textContent = userData.error;
                        if (userData.error.includes("Invalid username")) {
                            errorMessage.textContent += ' Try setting a custom URL in Steam or use your SteamID64 instead.';
                        } else if (userData.error.includes("profile is private")) {
                            errorMessage.textContent += ' Please set your game details to public in Steam (Settings > Privacy).';
                        }
                    } else {
                        // Filter out invalid game entries
                        allGames = userData.games.filter(game => game && typeof game === 'object' && 'appid' in game && 'name' in game);
                        steamId = userData.steam_id;
                        steamIdDisplay.textContent = steamId;
                        copyButton.style.display = 'inline';

                        renderStats();
                        renderPlaytimeTrends();
                        renderTopGames();
                        renderRecentGames();
                    }

                    // Fetch the paginated list for the Full List section
                    fetchPaginatedGames(currentPage);
                })
                .catch(error => {
                    errorMessage.textContent = 'Error fetching data: ' + error.message;
                    console.error('Fetch error:', error);
                });

            if (friendInput) {
                const friendUrl = /^\d{17}$/.test(friendInput) ?
                    `/get_library_by_id?steamid=${encodeURIComponent(friendInput)}&page=1&per_page=2000` :
                    `/get_library?username=${encodeURIComponent(friendInput)}&page=1&per_page=2000`;
                fetch(friendUrl, { mode: 'cors' })
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                        return response.json();
                    })
                    .then(friendData => {
                        if (friendData.error) throw new Error(friendData.error);
                        friendGames = friendData.games.filter(game => game && typeof game === 'object' && 'appid' in game && 'name' in game);
                        renderComparison();
                    })
                    .catch(error => {
                        compareList.innerHTML = `<li>Error fetching friend's library: ${error.message}</li>`;
                    });
            }
        }

        function fetchPaginatedGames(page) {
            const params = {
                page: page,
                per_page: gamesPerPage,
                showPlayedOnly: document.getElementById('showPlayedOnly').checked,
                filterWindows: document.getElementById('filterWindows').checked,
                filterMac: document.getElementById('filterMac').checked,
                filterLinux: document.getElementById('filterLinux').checked,
                filterDeck: document.getElementById('filterDeck').checked,
                search: document.getElementById('searchInput').value.trim(),
                sortBy: document.getElementById('sortBy').value,
                dateRange: document.getElementById('dateRange').value
            };
            const queryString = Object.keys(params).map(key => `${key}=${encodeURIComponent(params[key])}`).join('&');
            const url = `${userUrl}&${queryString}`;

            console.log('Fetching paginated games with URL:', url);

            fetch(url, { mode: 'cors' })
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    return response.json();
                })
                .then(userData => {
                    console.log('Fetched paginated data for page:', page, userData);
                    console.log('Total pages received:', userData.total_pages);
                    console.log('Total games received:', userData.total_games);
                    if (userData.error) {
                        document.getElementById('errorMessage').textContent = userData.error;
                    } else {
                        // Filter out invalid game entries
                        currentPageGames = userData.games.filter(game => game && typeof game === 'object' && 'appid' in game && 'name' in game);
                        totalPages = userData.total_pages;
                        totalGames = userData.total_games;
                        renderGames();
                    }
                })
                .catch(error => {
                    document.getElementById('errorMessage').textContent = 'Error fetching paginated data: ' + error.message;
                    console.error('Fetch error:', error);
                });
        }

        function renderStats() {
            const statsList = document.getElementById('statsList');
            const totalPlaytime = allGames.reduce((sum, game) => sum + (game.playtime_forever || 0), 0);
            const totalHours = Math.floor(totalPlaytime / 60);
            const playedGames = allGames.filter(game => (game.playtime_forever || 0) > 0);
            const avgPlaytime = playedGames.length > 0 ? Math.floor(totalPlaytime / playedGames.length / 60) : 0;
            const windowsPlaytime = allGames.reduce((sum, game) => sum + (game.playtime_windows_forever || 0), 0);
            const macPlaytime = allGames.reduce((sum, game) => sum + (game.playtime_mac_forever || 0), 0);
            const linuxPlaytime = allGames.reduce((sum, game) => sum + (game.playtime_linux_forever || 0), 0);
            const deckPlaytime = allGames.reduce((sum, game) => sum + (game.playtime_deck_forever || 0), 0);
            const mostActivePlatform = [
                { name: 'Windows', time: windowsPlaytime },
                { name: 'Mac', time: macPlaytime },
                { name: 'Linux', time: linuxPlaytime },
                { name: 'Steam Deck', time: deckPlaytime }
            ].sort((a, b) => b.time - a.time)[0].name;

            statsList.innerHTML = `
                <li>Total Playtime: ${totalHours} hours</li>
                <li>Total Games: ${allGames.length}</li>
                <li>Games Played: ${playedGames.length}</li>
                <li>Average Playtime per Played Game: ${avgPlaytime} hours</li>
                <li>Most Active Platform: ${mostActivePlatform}</li>
            `;
        }

        function renderPlaytimeTrends() {
            const monthlyPlaytime = {};
            allGames.forEach(game => {
                if (game.rtime_last_played) {
                    const date = new Date(game.rtime_last_played * 1000);
                    const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                    monthlyPlaytime[monthYear] = (monthlyPlaytime[monthYear] || 0) + (game.playtime_forever || 0);
                }
            });

            const labels = Object.keys(monthlyPlaytime).sort();
            const data = labels.map(label => Math.floor(monthlyPlaytime[label] / 60));

            const ctx = document.getElementById('playtimeChart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Playtime (Hours)',
                        data: data,
                        borderColor: '#4caf50',
                        fill: false
                    }]
                },
                options: {
                    scales: {
                        x: { title: { display: true, text: 'Month' } },
                        y: { title: { display: true, text: 'Hours Played' } }
                    }
                }
            });
        }

        function renderTopGames() {
            const topGamesList = document.getElementById('topGamesList');
            const topGames = [...allGames]
                .sort((a, b) => (b.playtime_forever || 0) - (a.playtime_forever || 0))
                .slice(0, 20);
            const maxPlaytime = Math.max(...allGames.map(game => game.playtime_forever || 0));

            topGamesList.innerHTML = '';
            topGames.forEach(game => {
                const li = document.createElement('li');
                const hours = Math.floor((game.playtime_forever || 0) / 60);
                const lastPlayed = game.rtime_last_played ? new Date(game.rtime_last_played * 1000).toLocaleDateString() : 'Never';
                const playtime2Weeks = game.playtime_2weeks ? Math.floor(game.playtime_2weeks / 60) : 0;
                li.classList.add('lazy-load');
                li.dataset.appid = game.appid;
                li.innerHTML = `
                    <div class="game-item">
                        <img src="http://media.steampowered.com/steamcommunity/public/images/apps/${game.appid}/${game.img_icon_url}.jpg" alt="${game.name} icon">
                        <span class="game-name ${favorites.includes(game.appid) ? 'favorite' : ''}">${game.name}</span>
                        <button class="favorite-btn">${favorites.includes(game.appid) ? '★' : '☆'}</button>
                        <div class="playtime-bar">
                            <div class="playtime-bar-fill" style="width: ${maxPlaytime > 0 ? ((game.playtime_forever || 0) / maxPlaytime) * 100 : 0}%;"></div>
                        </div>
                        <span class="game-playtime">${hours} hours played (Last played: ${lastPlayed}${playtime2Weeks > 0 ? `, ${playtime2Weeks} hours in last 2 weeks` : ''})</span>
                    </div>
                    <div class="game-details"></div>
                `;
                li.querySelector('.favorite-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleFavorite(game.appid);
                });
                topGamesList.appendChild(li);
            });

            setupLazyLoading();
        }

        function renderRecentGames() {
            const recentGamesList = document.getElementById('recentGamesList');
            const twoWeeksAgo = currentTimestamp - twoWeeksInSeconds;
            const recentGames = allGames.filter(game => 
                (game.playtime_2weeks && game.playtime_2weeks > 0) || 
                (game.rtime_last_played && game.rtime_last_played >= twoWeeksAgo)
            ).sort((a, b) => (b.rtime_last_played || 0) - (a.rtime_last_played || 0));
            const maxPlaytime = Math.max(...allGames.map(game => game.playtime_forever || 0));

            recentGamesList.innerHTML = '';
            if (recentGames.length === 0) {
                recentGamesList.innerHTML = '<li>No recently played games found.</li>';
                return;
            }

            recentGames.forEach(game => {
                const li = document.createElement('li');
                const hours = Math.floor((game.playtime_forever || 0) / 60);
                const lastPlayed = game.rtime_last_played ? new Date(game.rtime_last_played * 1000).toLocaleDateString() : 'Never';
                const playtime2Weeks = game.playtime_2weeks ? Math.floor(game.playtime_2weeks / 60) : 0;
                li.classList.add('lazy-load');
                li.dataset.appid = game.appid;
                li.innerHTML = `
                    <div class="game-item">
                        <img src="http://media.steampowered.com/steamcommunity/public/images/apps/${game.appid}/${game.img_icon_url}.jpg" alt="${game.name} icon">
                        <span class="game-name ${favorites.includes(game.appid) ? 'favorite' : ''}">${game.name}</span>
                        <button class="favorite-btn">${favorites.includes(game.appid) ? '★' : '☆'}</button>
                        <div class="playtime-bar">
                            <div class="playtime-bar-fill" style="width: ${maxPlaytime > 0 ? ((game.playtime_forever || 0) / maxPlaytime) * 100 : 0}%;"></div>
                        </div>
                        <span class="game-playtime">${hours} hours played (Last played: ${lastPlayed}${playtime2Weeks > 0 ? `, ${playtime2Weeks} hours in last 2 weeks` : ''})</span>
                    </div>
                    <div class="game-details"></div>
                `;
                li.querySelector('.favorite-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleFavorite(game.appid);
                });
                recentGamesList.appendChild(li);
            });

            setupLazyLoading();
        }

        function renderComparison() {
            const compareList = document.getElementById('compareList');
            const userGameNames = new Set(allGames.map(game => game.name));
            const friendGameNames = new Set(friendGames.map(game => game.name));

            const commonGames = [...userGameNames].filter(name => friendGameNames.has(name));
            const onlyUserGames = [...userGameNames].filter(name => !friendGameNames.has(name));
            const onlyFriendGames = [...friendGameNames].filter(name => !userGameNames.has(name));

            compareList.innerHTML = `
                <li><strong>Common Games (${commonGames.length}):</strong> ${commonGames.join(', ')}</li>
                <li><strong>Only in Your Library (${onlyUserGames.length}):</strong> ${onlyUserGames.join(', ')}</li>
                <li><strong>Only in Friend's Library (${onlyFriendGames.length}):</strong> ${onlyFriendGames.join(', ')}</li>
            `;
        }

        function renderGames() {
            const gameList = document.getElementById('gameList');
            const prevPageButton = document.getElementById('prevPage');
            const nextPageButton = document.getElementById('nextPage');
            const pageInfo = document.getElementById('pageInfo');
            const maxPlaytime = Math.max(...allGames.map(game => game.playtime_forever || 0));

            gameList.innerHTML = '';
            console.log('Rendering games for page:', currentPage, 'Total games on this page:', currentPageGames.length);

            if (currentPageGames.length === 0) {
                gameList.innerHTML = '<li>No games match your criteria.</li>';
                prevPageButton.disabled = true;
                nextPageButton.disabled = true;
                pageInfo.textContent = `Page ${currentPage} of ${totalPages || 1} (Total Games: ${totalGames})`;
                return;
            }

            currentPageGames.forEach(game => {
                const li = document.createElement('li');
                li.classList.add('lazy-load');
                li.dataset.appid = game.appid;
                gameList.appendChild(li);
            });

            pageInfo.textContent = `Page ${currentPage} of ${totalPages || 1} (Total Games: ${totalGames})`;
            prevPageButton.disabled = currentPage === 1;
            nextPageButton.disabled = currentPage === totalPages || totalPages === 0;

            // Add pagination event listeners (remove old ones to prevent duplicates)
            const prevPageButtonClone = prevPageButton.cloneNode(true);
            const nextPageButtonClone = nextPageButton.cloneNode(true);
            prevPageButton.parentNode.replaceChild(prevPageButtonClone, prevPageButton);
            nextPageButton.parentNode.replaceChild(nextPageButtonClone, nextPageButton);

            prevPageButtonClone.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    fetchPaginatedGames(currentPage);
                    savePreferences();
                    updateShareableLink();
                }
            });
            nextPageButtonClone.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    fetchPaginatedGames(currentPage);
                    savePreferences();
                    updateShareableLink();
                }
            });

            setupLazyLoading();
        }

        function toggleDetails(element) {
            const detailsDiv = element.nextElementSibling;
            if (!detailsDiv.innerHTML.includes('unlocked') && !detailsDiv.innerHTML.includes('No achievements')) {
                const game = currentPageGames.find(g => g.appid == element.parentElement.dataset.appid);
                const steamIdDisplay = document.getElementById('steamId');
                fetch(`/get_achievements?steamid=${steamIdDisplay.textContent}&appid=${game.appid}`, { mode: 'cors' })
                    .then(response => response.json())
                    .then(achData => {
                        if (achData.error) {
                            detailsDiv.innerHTML = detailsDiv.innerHTML.replace('Achievements: Loading...', `<p>Achievements: ${achData.error}</p>`);
                        } else {
                            const achieved = achData.achievements ? achData.achievements.filter(ach => ach.achieved === 1).length : 0;
                            const total = achData.achievements ? achData.achievements.length : 0;
                            detailsDiv.innerHTML = detailsDiv.innerHTML.replace('Achievements: Loading...', `<p>Achievements: ${achieved}/${total} unlocked</p>`);
                        }
                    })
                    .catch(error => {
                        detailsDiv.innerHTML = detailsDiv.innerHTML.replace('Achievements: Loading...', `<p>Achievements: Error fetching data</p>`);
                    });
            }
            detailsDiv.style.display = detailsDiv.style.display === 'none' ? 'block' : 'none';
        }

        function setupLazyLoading() {
            const maxPlaytime = Math.max(...allGames.map(game => game.playtime_forever || 0));
            const steamIdDisplay = document.getElementById('steamId');
            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const li = entry.target;
                        const game = currentPageGames.find(g => g.appid == li.dataset.appid);
                        if (!game) return; // Skip if game is not found
                        const hours = Math.floor((game.playtime_forever || 0) / 60);
                        const lastPlayed = game.rtime_last_played ? new Date(game.rtime_last_played * 1000).toLocaleDateString() : 'Never';
                        const playtime2Weeks = game.playtime_2weeks ? Math.floor(game.playtime_2weeks / 60) : 0;
                        li.innerHTML = `
                            <div class="game-item" onclick="toggleDetails(this)">
                                <img src="http://media.steampowered.com/steamcommunity/public/images/apps/${game.appid}/${game.img_icon_url}.jpg" alt="${game.name} icon">
                                <span class="game-name ${favorites.includes(game.appid) ? 'favorite' : ''}">${game.name}</span>
                                <button class="favorite-btn">${favorites.includes(game.appid) ? '★' : '☆'}</button>
                                <div class="playtime-bar">
                                    <div class="playtime-bar-fill" style="width: ${maxPlaytime > 0 ? ((game.playtime_forever || 0) / maxPlaytime) * 100 : 0}%;"></div>
                                </div>
                                <span class="game-playtime">${hours} hours played (Last played: ${lastPlayed}${playtime2Weeks > 0 ? `, ${playtime2Weeks} hours in last 2 weeks` : ''})</span>
                            </div>
                            <div class="game-details">
                                <p>App ID: ${game.appid}</p>
                                <p>Windows Playtime: ${Math.floor((game.playtime_windows_forever || 0) / 60)} hours</p>
                                <p>Mac Playtime: ${Math.floor((game.playtime_mac_forever || 0) / 60)} hours</p>
                                <p>Linux Playtime: ${Math.floor((game.playtime_linux_forever || 0) / 60)} hours</p>
                                <p>Steam Deck Playtime: ${Math.floor((game.playtime_deck_forever || 0) / 60)} hours</p>
                                ${game.content_descriptorids ? `<p>Content Descriptors: ${game.content_descriptorids.join(', ')}</p>` : ''}
                                ${game.details && Object.keys(game.details).length > 0 ? `
                                    <p>Genres: ${game.details.genres ? game.details.genres.join(', ') : 'Unknown'}</p>
                                    <p>Release Date: ${game.details.release_date || 'Unknown'}</p>
                                    <p>Categories: ${game.details.categories ? game.details.categories.join(', ') : 'Unknown'}</p>
                                ` : '<p>Details not available (fetchDetails=false)</p>'}
                                <p>Achievements: Loading...</p>
                            </div>
                        `;
                        li.querySelector('.favorite-btn').addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleFavorite(game.appid);
                        });
                        observer.unobserve(li);
                    }
                });
            }, { rootMargin: '0px 0px 200px 0px' });

            document.querySelectorAll('.lazy-load').forEach(li => observer.observe(li));
        }

        function toggleFavorite(appid) {
            if (favorites.includes(appid)) {
                favorites = favorites.filter(id => id !== appid);
            } else {
                favorites.push(appid);
            }
            localStorage.setItem('favorites', JSON.stringify(favorites));
            renderGames();
            renderTopGames();
            renderRecentGames();
        }

        function savePreferences() {
            const preferences = {
                showPlayedOnly: document.getElementById('showPlayedOnly').checked,
                filterWindows: document.getElementById('filterWindows').checked,
                filterMac: document.getElementById('filterMac').checked,
                filterLinux: document.getElementById('filterLinux').checked,
                filterDeck: document.getElementById('filterDeck').checked,
                search: document.getElementById('searchInput').value.trim(),
                sortBy: document.getElementById('sortBy').value,
                dateRange: document.getElementById('dateRange').value,
                page: currentPage,
                steamId: steamId
            };
            localStorage.setItem('steamLibraryPrefs', JSON.stringify(preferences));
        }

        function loadPreferences() {
            const preferences = JSON.parse(localStorage.getItem('steamLibraryPrefs')) || {};
            document.getElementById('showPlayedOnly').checked = preferences.showPlayedOnly || false;
            document.getElementById('filterWindows').checked = preferences.filterWindows || false;
            document.getElementById('filterMac').checked = preferences.filterMac || false;
            document.getElementById('filterLinux').checked = preferences.filterLinux || false;
            document.getElementById('filterDeck').checked = preferences.filterDeck || false;
            document.getElementById('searchInput').value = preferences.search || '';
            document.getElementById('sortBy').value = preferences.sortBy || 'name';
            document.getElementById('dateRange').value = preferences.dateRange || 'all';
            currentPage = preferences.page || 1;
            steamId = preferences.steamId || '';
            if (steamId) {
                document.getElementById('userInput').value = steamId;
                fetchAndRender();
            }
        }

        function loadFromUrlParams() {
            const params = new URLSearchParams(window.location.search);
            document.getElementById('showPlayedOnly').checked = params.get('showPlayedOnly') === 'true';
            document.getElementById('filterWindows').checked = params.get('filterWindows') === 'true';
            document.getElementById('filterMac').checked = params.get('filterMac') === 'true';
            document.getElementById('filterLinux').checked = params.get('filterLinux') === 'true';
            document.getElementById('filterDeck').checked = params.get('filterDeck') === 'true';
            document.getElementById('searchInput').value = params.get('search') || '';
            document.getElementById('sortBy').value = params.get('sortBy') || 'name';
            document.getElementById('dateRange').value = params.get('dateRange') || 'all';
            currentPage = parseInt(params.get('page')) || 1;
            steamId = params.get('steamid') || params.get('userInput') || '';
            if (steamId && !document.getElementById('userInput').value) {
                document.getElementById('userInput').value = steamId;
                fetchAndRender();
            } else {
                renderGames();
            }
        }

        function updateShareableLink() {
            const params = new URLSearchParams({
                steamid: steamId,
                showPlayedOnly: document.getElementById('showPlayedOnly').checked,
                filterWindows: document.getElementById('filterWindows').checked,
                filterMac: document.getElementById('filterMac').checked,
                filterLinux: document.getElementById('filterLinux').checked,
                filterDeck: document.getElementById('filterDeck').checked,
                search: document.getElementById('searchInput').value.trim(),
                sortBy: document.getElementById('sortBy').value,
                dateRange: document.getElementById('dateRange').value,
                page: currentPage
            });
            const shareableUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
            history.pushState(null, '', shareableUrl);
            return shareableUrl;
        }

        document.getElementById('exportCsv').addEventListener('click', () => {
            const filteredGames = currentPageGames;
            const csvContent = [
                ['Name', 'Playtime (Hours)', 'Last Played', 'Playtime Last 2 Weeks (Hours)'].join(','),
                ...filteredGames.map(game => {
                    const hours = Math.floor((game.playtime_forever || 0) / 60);
                    const lastPlayed = game.rtime_last_played ? new Date(game.rtime_last_played * 1000).toLocaleDateString() : 'Never';
                    const playtime2Weeks = game.playtime_2weeks ? Math.floor(game.playtime_2weeks / 60) : 0;
                    return [
                        `"${game.name.replace(/"/g, '""')}"`,
                        hours,
                        lastPlayed,
                        playtime2Weeks
                    ].join(',');
                })
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'steam_library.csv';
            link.click();
        });

        document.getElementById('shareLink').addEventListener('click', () => {
            const shareableUrl = updateShareableLink();
            navigator.clipboard.writeText(shareableUrl).then(() => {
                alert('Shareable link copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        });

        document.getElementById('darkModeToggle').addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
            document.getElementById('darkModeToggle').textContent = document.body.classList.contains('dark-mode') ? '☀️' : '🌙';
        });

        document.querySelectorAll('.toggle-section').forEach(button => {
            button.addEventListener('click', () => {
                const section = button.parentElement.nextElementSibling;
                section.style.display = section.style.display === 'none' ? 'block' : 'none';
            });
        });

        document.getElementById('copyButton').addEventListener('click', function() {
            const steamId = document.getElementById('steamId').textContent;
            navigator.clipboard.writeText(steamId).then(() => {
                alert('SteamID copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        });

        // Add filter and search event listeners
        document.getElementById('showPlayedOnly').addEventListener('change', () => {
            currentPage = 1;
            fetchPaginatedGames(currentPage);
            savePreferences();
            updateShareableLink();
        });
        document.getElementById('filterWindows').addEventListener('change', () => {
            currentPage = 1;
            fetchPaginatedGames(currentPage);
            savePreferences();
            updateShareableLink();
        });
        document.getElementById('filterMac').addEventListener('change', () => {
            currentPage = 1;
            fetchPaginatedGames(currentPage);
            savePreferences();
            updateShareableLink();
        });
        document.getElementById('filterLinux').addEventListener('change', () => {
            currentPage = 1;
            fetchPaginatedGames(currentPage);
            savePreferences();
            updateShareableLink();
        });
        document.getElementById('filterDeck').addEventListener('change', () => {
            currentPage = 1;
            fetchPaginatedGames(currentPage);
            savePreferences();
            updateShareableLink();
        });
        document.getElementById('searchInput').addEventListener('input', () => {
            currentPage = 1;
            fetchPaginatedGames(currentPage);
            savePreferences();
            updateShareableLink();
        });
        document.getElementById('sortBy').addEventListener('change', () => {
            currentPage = 1;
            fetchPaginatedGames(currentPage);
            savePreferences();
            updateShareableLink();
        });
        document.getElementById('dateRange').addEventListener('change', () => {
            currentPage = 1;
            fetchPaginatedGames(currentPage);
            savePreferences();
            updateShareableLink();
        });

        // Load initial state
        window.addEventListener('load', () => {
            loadPreferences();
            loadFromUrlParams();
            if (localStorage.getItem('darkMode') === 'true') {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeToggle').textContent = '☀️';
            } else {
                document.getElementById('darkModeToggle').textContent = '🌙';
            }
        });
    </script>
</body>
</html>